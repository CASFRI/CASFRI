rule_id,target_attribute,target_attribute_type,validation_rules,translation_rules,description,desc_uptodate_with_rules
0,ROW_TRANSLATION_RULE,NA,"isLessThan(layer, lookupText(cl_age, 'translation', 'qc_standstructure_lookup', 'source_val', 'num_of_layers'), TRUE)",NA,"Forest polygons must have a cl_age value. Lookup the number of LYR layers in the lookup table, only run if the layer being translated is less than or equal to the num_of_layers. If polygon has 2 lyr layers, it should be translated for both layer 1 and 2, if polygon only has 1 lyr layer, it should not be translated when layer = 2.", TRUE
1,CAS_ID,text,notEmpty(inventory_id);notEmpty(src_filename);notNull(geocode_1_10);notNull(geocode_11_20),"padConcat({inventory_id, src_filename, geocode_1_10, geocode_11_20, ''}, {4,15,10,10,7}, {'x','x','x','x','x'}, '-', TRUE, TRUE)",Concatenates five attributes to create CAS_ID. Geocode_1_10 and geocode_11_20 are the original geocode string split into the first ten and second ten characters. Commas are replaced with periods for use in the cas_id.,TRUE
2,SOIL_MOIST_REG,text,"notNull(soil_moist_reg);matchList(soil_moist_reg,{'00','10','11','12','13','14','20','21','22','23','24','30','31','32','33','34','40','41','42','43','44','50','51','52','53','54','60','61','62','63','64'})
","mapText(soil_moist_reg, {'00','10','11','12','13','14','20','21','22','23','24','30','31','32','33','34','40','41','42','43','44','50','51','52','53','54','60','61','62','63','64'}, {'DRY','DRY','DRY','DRY','DRY','DRY','MESIC','MESIC','MESIC','MESIC','MESIC','MESIC','MESIC','MESIC','MESIC','MESIC','MOIST','MOIST','MOIST','MOIST','MOIST','WET','WET','WET','WET','WET','AQUATIC','AQUATIC','AQUATIC','AQUATIC','AQUATIC'})",Maps source codes to CASFRI codes. Report 16 as NOT_IN_SET.,TRUE
3,STRUCTURE_PER,integer,true(),copyInt(100),No horizontal structure so structure_per should always be 100,TRUE
4,STRUCTURE_RANGE,double precision,false(),nothingDouble(),Complex stands record height for the top layer only,TRUE
5,LAYER,integer,true(),"qc_countOfNotNull(cl_age, co_ter, layer)","Uses the qc_standstructure_lookup table to find number of lyr layers, then tests to see if nfl is present and counts the total number of layers. Returns layers number based on the layer being translated. Since height for layer 2 is always unknown, no need to order layers by height, just report layers in the same order as source inventory.",TRUE
6,LAYER_RANK,integer,false(|-8887),nothingInt(),No rank attribute,TRUE
7,CROWN_CLOSURE_UPPER,integer,"notNull(crown_closure_age);lookupTextMatchList(crown_closure_age, 'translation', 'qc_standstructure_lookup', 'num_of_layers', 1|-8886);notNull(crown_closure_dens);notEmpty(crown_closure_dens);notMatchList(crown_closure_dens, {'H', 'I'} |-8887);matchList(crown_closure_dens, {'A', 'B', 'C', 'D'})","mapInt(crown_closure_dens, {'A', 'B', 'C', 'D'}, {100, 79, 59, 39})","Validation rules: 1) check cl_age is not null, if it is polygon is NFL. 2) check cl_age code is in the lookup table. 3) check number of layers.  4) if there are 2 layers, nothing to return. cl_dens only has one value for the entire polygon, it cannot be split by layer.       Translation rule: If cl_age has a value indicate that layers is 1, map cl_dens.  cl_dens is a code representing intervals, return the upper value from the relavent interval. We can't return anything for layer 2, and we can't return anything if number of layer is 2 because cl_dens is a polygon level measure.",TRUE
8,CROWN_CLOSURE_LOWER,integer,"notNull(crown_closure_age);lookupTextMatchList(crown_closure_age, 'translation', 'qc_standstructure_lookup', 'num_of_layers', 1|-8886);notNull(crown_closure_dens);notEmpty(crown_closure_dens);notMatchList(crown_closure_dens, {'H', 'I'} |-8887);matchList(crown_closure_dens, {'A', 'B', 'C', 'D'})","mapInt(crown_closure_dens, {'A', 'B', 'C', 'D'}, {80, 60, 40, 25})","Validation rules: 1) check cl_age is not null, if it is polygon is NFL. 2) check cl_age code is in the lookup table. 3) check number of layers.  4) there are 2 layers, nothing to return. cl_dens only has one value for the entire polygon, it cannot be split by layer.       Translation rule: If cl_age has a value indicate that layers is 1, map cl_dens.  cl_dens is a code representing intervals, return the upper value from the relavent interval. We can't return anything for layer 2, and we can't return anything if number of layer is 2 because cl_dens is a polygon level measure.",TRUE
9,HEIGHT_UPPER,double precision,"matchList(layer, 1|-8886);notNull(height_upper);notEmpty(height_upper);isBetween(height_upper,0,100,FALSE,TRUE)","mapDouble(height_upper, {'1','2','3','4','5','6','7'}, {100, 21, 16, 11, 6, 3, 1})","Uses same logic as crown closure but returns height. The only difference is cl_haut represets the height of the top layer. So if 2 layers, layer 1 height is always cl_haut, and layer 2 height is always unknown.",TRUE
10,HEIGHT_LOWER,double precision,"matchList(layer, 1|-8886);notNull(height_lower);notEmpty(height_lower);isBetween(height_lower,0,100,FALSE,TRUE)","mapDouble(height_lower, {'1','2','3','4','5','6','7'}, {22, 17, 12, 7, 4, 2, 0})","Uses same logic as crown closure but returns height. The only difference is cl_haut represets the height of the top layer. So if 2 layers, layer 1 height is always cl_haut, and layer 2 height is always unknown.",TRUE
11,PRODUCTIVITY,text,false(),nothingText(),Attribute does not occur,TRUE
12,PRODUCTIVITY_TYPE,text,false(),nothingText(),Attribute does not occur,TRUE
13,SPECIES_1,text,"matchList(layer, 1|UNKNOWN_VALUE);notNull(species_1);notEmpty(species_1);matchTable(species_1, 'translation', 'qc_ini03_species_lookup', 'source_val',TRUE);lookupTextMatchList(species_1, 'translation', 'qc_ini03_species_lookup', 'num_of_species',{1,2,3}|NOT_APPLICABLE)","lookupText(species_1, 'translation', 'qc_ini03_species_lookup', 'source_val', 'species_1', TRUE)",Only runs if layer is 1. We don't have species info for layer 2 so return UNKNWON_VALUE. Maps source value to SPECIES_1 using lookup table.,TRUE
14,SPECIES_PER_1,integer,"matchList(layer, 1|-8886);notNull(species_per_1);notEmpty(species_per_1);matchTable(species_per_1, 'translation', 'qc_ini03_species_lookup', 'source_val',TRUE);lookupTextMatchList(species_per_1, 'translation', 'qc_ini03_species_lookup', 'num_of_species', {1,2,3}|-8887)","lookupInt(species_per_1, 'translation', 'qc_ini03_species_lookup', 'source_val', 'species_per_1', TRUE)",Only runs if layer is 1. We don't have species info for layer 2 so return UNKNWON_VALUE. Maps source value to SPECIES_PER_1 using lookup table,TRUE
15,SPECIES_2,text,"matchList(layer, 1|UNKNOWN_VALUE);notNull(species_2);notEmpty(species_2);matchTable(species_2, 'translation', 'qc_ini03_species_lookup', 'source_val',TRUE);lookupTextMatchList(species_2, 'translation', 'qc_ini03_species_lookup', 'num_of_species',{2,3}|NOT_APPLICABLE)","lookupText(species_2, 'translation', 'qc_ini03_species_lookup', 'source_val', 'species_2',TRUE)",Only runs if layer is 1. We don't have species info for layer 2 so return UNKNWON_VALUE. Maps source value to SPECIES_2 using lookup table,TRUE
16,SPECIES_PER_2,integer,"matchList(layer, 1|-8886);notNull(species_per_2);notEmpty(species_per_2);matchTable(species_per_2, 'translation', 'qc_ini03_species_lookup', 'source_val',TRUE);lookupTextMatchList(species_per_2, 'translation', 'qc_ini03_species_lookup', 'num_of_species', {2,3}|-8887)","lookupInt(species_per_2, 'translation', 'qc_ini03_species_lookup', 'source_val', 'species_per_2',TRUE)",Only runs if layer is 1. We don't have species info for layer 2 so return UNKNWON_VALUE. Maps source value to SPECIES_PER_2 using lookup table,TRUE
17,SPECIES_3,text,"matchList(layer, 1|UNKNOWN_VALUE);notNull(species_3);notEmpty(species_3);matchTable(species_3, 'translation', 'qc_ini03_species_lookup', 'source_val',TRUE);lookupTextMatchList(species_3, 'translation', 'qc_ini03_species_lookup', 'num_of_species', 3|NOT_APPLICABLE)","lookupText(species_3, 'translation', 'qc_ini03_species_lookup', 'source_val', 'species_3', TRUE)",Only runs if layer is 1. We don't have species info for layer 2 so return UNKNWON_VALUE. Maps source value to SPECIES_3 using lookup table,TRUE
18,SPECIES_PER_3,integer,"matchList(layer, 1|-8886);notNull(species_per_3);notEmpty(species_per_3);matchTable(species_per_3, 'translation', 'qc_ini03_species_lookup', 'source_val',TRUE);lookupTextMatchList(species_per_3, 'translation', 'qc_ini03_species_lookup', 'num_of_species', 3|-8887)","lookupInt(species_per_3, 'translation', 'qc_ini03_species_lookup', 'source_val', 'species_per_3', TRUE)",Only runs if layer is 1. We don't have species info for layer 2 so return UNKNWON_VALUE. Maps source value to SPECIES_PER_3 using lookup table,TRUE
19,SPECIES_4,text,false(),nothingText(),attribute does not occur,TRUE
20,SPECIES_PER_4,integer,false(),nothingInt(),attribute does not occur,TRUE
21,SPECIES_5,text,false(),nothingText(),attribute does not occur,TRUE
22,SPECIES_PER_5,integer,false(),nothingInt(),attribute does not occur,TRUE
23,SPECIES_6,text,false(),nothingText(),attribute does not occur,TRUE
24,SPECIES_PER_6,integer,false(),nothingInt(),attribute does not occur,TRUE
25,SPECIES_7,text,false(),nothingText(),attribute does not occur,TRUE
26,SPECIES_PER_7,integer,false(),nothingInt(),attribute does not occur,TRUE
27,SPECIES_8,text,false(),nothingText(),attribute does not occur,TRUE
28,SPECIES_PER_8,integer,false(),nothingInt(),attribute does not occur,TRUE
29,SPECIES_9,text,false(),nothingText(),attribute does not occur,TRUE
30,SPECIES_PER_9,integer,false(),nothingInt(),attribute does not occur,TRUE
31,SPECIES_10,text,false(),nothingText(),attribute does not occur,TRUE
32,SPECIES_PER_10,integer,false(),nothingInt(),attribute does not occur,TRUE
33,ORIGIN_UPPER,integer,"matchList(layer, 1|-8886);isInt(stand_photo_year|-8886);notNull(cl_age);notEmpty(cl_age);matchTable(cl_age, 'translation', 'qc_standstructure_lookup', 'source_val',TRUE)","qc_origin_translation(lookupInt(cl_age, 'translation', 'qc_standstructure_lookup', 'source_val', 'l1_age_origin', TRUE), stand_photo_year)","Map age using lookup table, then calculates origin as photo year minus age. Note that photo year is not provided in the original inventory. Inventory provides photo_interpretation_year which is always within 1-3 years from original photo_year. We decided the values were close enough to be used in the translation of origin. Only runs if layer is 1. We don't have species info for layer 2 so return UNKNWON_VALUE. Validation checks that the year is an integer,  the age is not null or not empty and the age match the lookuptable",TRUE
34,ORIGIN_LOWER,integer,"matchList(layer, 1|-8886);isInt(stand_photo_year|-8886);notNull(cl_age);notEmpty(cl_age);matchTable(cl_age, 'translation', 'qc_standstructure_lookup', 'source_val',TRUE)","qc_origin_translation(lookupInt(cl_age, 'translation', 'qc_standstructure_lookup', 'source_val', 'l1_age_origin', TRUE), stand_photo_year)","Map age using lookup table, then calculates origin as photo year minus age. Note that photo year is not provided in the original inventory. Inventory provides photo_interpretation_year which is always within 1-3 years from original photo_year. We decided the values were close enough to be used in the translation of origin. Only runs if layer is 1. We don't have species info for layer 2 so return UNKNWON_VALUE. Validation checks that the year is an integer,  the age is not null or not empty and the age match the lookuptable",TRUE
35,SITE_CLASS,text,false(),nothingText(),Attribute does not occur,TRUE
36,SITE_INDEX,double precision,false(),nothingDouble(),Attribute does not occur,TRUE
