rule_id,target_attribute,target_attribute_type,validation_rules,translation_rules,description,desc_uptodate_with_rules
1,CAS_ID,text,notEmpty(inventory_id);notNull(src_filename);notNull(forest_id_2);notNull(ogc_fid),"padConcat({inventory_id, 'CANFOR', src_filename, forest_id_2, ogc_fid}, {4,15,10,10,7}, {'x','x','x','0','0'}, '-', 'TRUE', 'TRUE')",Concatenates five attributes to create CAS_ID,TRUE
2,SOIL_MOIST_REG,text,"notNull(moisture);matchList(moisture,{'a','A','d','D','m','M','w','W'})","mapText(moisture, {'a','A','d','D','m','M','w','W'}, {'A','A','D','D','F','F','W','W'})",Maps source value to SOIL_MOIST_REG using lists of values,TRUE
3,STRUCTURE_PER,integer,"notNull(std_struct);isInt(std_struct);matchList(std_struct,{' 0',0,'C4','C5','M','M0','MO'})","mapInt(std_struct, {' 0',0,'C4','C5','M','M0','MO'}, {'-9999','-9999',4,5,'-9999','-9999','-9999'})",Copy source value to STRUCTURE_PER,TRUE
4,LAYER,integer,true(),copyInt(1),Copy value of 1 to LAYER,TRUE
5,LAYER_RANK,integer,true(),copyInt(1),Copy value of 1 to LAYER_RANK,TRUE
6,CROWN_CLOSURE_UPPER,integer,"notNull(crownclose);matchList(crownclose,{'A','B','C','D'})","mapInt(crownclose, {'A','B','C','D'}, {30,50,70,100})",Maps source value to CROWN_CLOSURE_UPPER using lists of values,TRUE
7,CROWN_CLOSURE_LOWER,integer,"notNull(crownclose);matchList(crownclose,{'A','B','C','D'})","mapInt(crownclose, {'A','B','C','D'}, {6,31,51,71})",Maps source value to CROWN_CLOSURE_LOWER using lists of values,TRUE
8,HEIGHT_UPPER,double precision,"notNull(height);isNumeric(height);isGreaterThan(height,1);isLessThan(height,100)",copyDouble(height),Copies source value to HEIGHT_UPPER,TRUE
9,HEIGHT_LOWER,double precision,"notNull(height);isNumeric(height);isGreaterThan(height,1);isLessThan(height,100)",copyDouble(height),Copies source value to HEIGHT_LOWER,TRUE
10,NAT_NON_VEG,text,"notNull(nat_nonveg);notEmpty(nat_nonveg);matchList(nat_nonveg,{'MB','MC','MS','WF','WL','WR'})","mapText(nat_nonveg,{'MB','MC','MS','WF','WL','WR'},{'EX','RK','WS','FL','LA','RI'})",Maps source value to NAT_NON_VEG using list of values,TRUE
11,NON_FOR_ANTH,text,"countNotNull({anth_noveg, anthro_veg}, 1, 'TRUE', 'TRUE');matchList(anth_noveg, {'IW','PR','IP','P','A','IG','IH','II','SR'}, 'FALSE', 'TRUE');matchList(anthro_veg, {'IW','PR','IP','P','A','IG','IH','II','SR'}, 'FALSE', 'TRUE')","avi01_non_for_anth_translation(anth_noveg, anthro_veg, {'IW','PR','IP','P','A','IG','IH','II','SR'}, {'CL','FA','FA','CL','CL','IN','FA','IN','SE'}, 'FALSE')","Custom CASFRI map function merges anth_noveg and anthro_veg then runs mapText(anth_noveg_anthro_veg, 'IW,PR,IP,P,A,IG,IH,II,SR', 'CL,FA,FA,CL,CL,IN,FA,IN,SE'). Validation functions check exactly one input has a value, and that the value is in the match list.",TRUE
12,NON_FOR_VEG,text,"notNull(nonfor_veg);notEmpty(nonfor_veg);matchList(nonfor_veg,{'BR','HF','HG','SC','SO'})","mapText(nonfor_veg,{'BR','HF','HG','SC','SO'},{'BR','HF','HG','SC','SO'})",Maps source value to NON_FOR_VEG using list of values. FLAG-map list matches fri list. Is this correct?,TRUE
