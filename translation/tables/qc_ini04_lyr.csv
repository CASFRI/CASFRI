rule_id,target_attribute,target_attribute_type,validation_rules,translation_rules,description,desc_uptodate_with_rules
0,ROW_TRANSLATION_RULE,NA,"isLessThan(layer, lookupText(cl_age, 'translation', 'qc_standstructure_lookup', 'source_val', 'num_of_layers'), TRUE)",NA,"Forest polygons must have a cl_age value. Lookup the number of LYR layers in the lookup table, only run if the layer being translated is less than or equal to the num_of_layers. If polygon has 2 lyr layers, it should be translated for both layer 1 and 2, if polygon only has 1 lyr layer, it should not be translated when layer = 2.", TRUE
1,CAS_ID,text,notEmpty(inventory_id);notEmpty(src_filename);notNull(geocode_1_10);notNull(geocode_11_20),"padConcat({inventory_id, src_filename, geocode_1_10, geocode_11_20, ''}, {4,15,10,10,7}, {'x','x','x','x','x'}, '-', TRUE, TRUE)",Concatenates five attributes to create CAS_ID. Geocode_1_10 and geocode_11_20 are the original geocode string split into the first ten and second ten characters. Commas are replaced with periods for use in the cas_id.,TRUE
2,SOIL_MOIST_REG,text,"notNull(soil_moist_reg);matchList(soil_moist_reg,{'00','10','11','12','13','14','20','21','22','23','24','30','31','32','33','34','40','41','42','43','44','50','51','52','53','54','60','61','62','63','64'})
","mapText(soil_moist_reg, {'00','10','11','12','13','14','20','21','22','23','24','30','31','32','33','34','40','41','42','43','44','50','51','52','53','54','60','61','62','63','64'}, {'DRY','DRY','DRY','DRY','DRY','DRY','MESIC','MESIC','MESIC','MESIC','MESIC','MESIC','MESIC','MESIC','MESIC','MESIC','MOIST','MOIST','MOIST','MOIST','MOIST','WET','WET','WET','WET','WET','AQUATIC','AQUATIC','AQUATIC','AQUATIC','AQUATIC'})",Maps source codes to CASFRI codes. Report 16 as NOT_IN_SET,TRUE
3,STRUCTURE_PER,integer,true(),copyInt(100),Structure_per should always be 100. No horizontal structure.,TRUE
4,STRUCTURE_RANGE,double precision,false(),nothingDouble(),Complex stands record height for the top layer only,TRUE
5,LAYER,integer,true(),"qc_countOfNotNull(lookupText(cl_age, 'translation', 'qc_standstructure_lookup', 'source_val', 'num_of_layers'), co_ter, layer)","Uses the qc_standstructure_lookup table to find number of lyr layers, then tests to see if nfl is present and counts the total number of layers. Returns layers number based on the layer being translated. Since height for layer 2 is always unknown, no need to order layers by height, just report layers in the same order as source inventory.",TRUE
6,LAYER_RANK,integer,false(),nothingInt(),No rank attribute,TRUE
7,CROWN_CLOSURE_UPPER,integer,"matchList(layer, 1|-8886);notNull(crown_closure_dens);notEmpty(crown_closure_dens);notMatchList(crown_closure_dens, {'H', 'I'} |-8887);matchList(crown_closure_dens, {'A', 'B', 'C', 'D'})","mapInt(crown_closure_dens, {'A', 'B', 'C', 'D'}, {100, 79, 59, 39})","Value represents layer 1 crown closure. Check value is not null and has an expected value. crown_closure_dens is a code representing intervals, return the upper value from the relavent interval. We can't return anything for layer 2.",TRUE
8,CROWN_CLOSURE_LOWER,integer,"matchList(layer, 1|-8886);notNull(crown_closure_dens);notEmpty(crown_closure_dens);notMatchList(crown_closure_dens, {'H', 'I'} |-8887);matchList(crown_closure_dens, {'A', 'B', 'C', 'D'})","mapInt(crown_closure_dens, {'A', 'B', 'C', 'D'}, {80, 60, 40, 25})","Value represents layer 1 crown closure. Check value is not null and has an expected value. crown_closure_dens is a code representing intervals, return the lower value from the relavent interval. We can't return anything for layer 2.",TRUE
9,HEIGHT_UPPER,double precision,"matchList(layer, 1|-8886);notNull(height_upper);notEmpty(height_upper);isBetween(height_upper,1,7|-9997)","mapDouble(height_upper, {1,2,3,4,5,6,7}, {100, 21, 16, 11, 6, 3, 1})","Value represents layer 1 height. Check value is not null and has an expected value. height is a code representing intervals, return the upper value from the relavent interval. We can't return anything for layer 2.",TRUE
10,HEIGHT_LOWER,double precision,"matchList(layer, 1|-8886);notNull(height_lower);notEmpty(height_lower);isBetween(height_lower,1,7|-9997)","mapDouble(height_lower, {1,2,3,4,5,6,7}, {22, 17, 12, 7, 4, 2, 0})","Value represents layer 1 height. Check value is not null and has an expected value. height is a code representing intervals, return the lower value from the relavent interval. We can't return anything for layer 2.",TRUE
11,PRODUCTIVITY,text,false(),nothingText(),Attribute does not occur,TRUE
12,PRODUCTIVITY_TYPE,text,false(),nothingText(),Attribute does not occur,TRUE
13,SPECIES_1,text,"matchList(layer, 1|UNKNOWN_VALUE);notNull(species_1);notEmpty(species_1);qc_prg4_lengthMatchList(species_1, {2, 4, 6}|NULL_VALUE)","lookupText(qc_prg4_species(species_1, 1), 'translation', 'species_code_mapping', 'qc_species_codes', 'casfri_species_codes')",Maps source value to SPECIES_1 using lookup table. Only runs if layer is 1. We don't have species info for layer 2 so return UNKNOWN_VALUE. ,TRUE
14,SPECIES_PER_1,integer,"matchList(layer, 1|-8886);notNull(species_per_1);notEmpty(species_per_1);qc_prg4_lengthMatchList(species_1, {2, 4, 6}|-8888)","qc_prg4_species_per_translation(species_per_1, 1)",Derives SPECIES_PER_1 from gr_ess. Custom function uses gr_ess to count number of species and assignes respective SPECIES_PER according to position. Only runs if layer is 1. We don't have species info for layer 2 so return UNKNOWN_VALUE. ,TRUE
15,SPECIES_2,text,"matchList(layer, 1|UNKNOWN_VALUE);notNull(species_2);notEmpty(species_2);qc_prg4_lengthMatchList(species_2, {4, 6}|NULL_VALUE)","lookupText(qc_prg4_species(species_2, 2), 'translation', 'species_code_mapping', 'qc_species_codes', 'casfri_species_codes')",Maps source value to SPECIES_2 using lookup table. Only runs if layer is 1. We don't have species info for layer 2 so return UNKNOWN_VALUE. ,TRUE
16,SPECIES_PER_2,integer,"matchList(layer, 1|-8886);notNull(species_per_2);notEmpty(species_per_2);qc_prg4_lengthMatchList(species_2, {4, 6}|-8888)","qc_prg4_species_per_translation(species_per_2, 2)",Derives SPECIES_PER_3 from gr_ess. Custom function uses gr_ess to count number of species and assignes respective SPECIES_PER according to position. Only runs if layer is 1. We don't have species info for layer 2 so return UNKNOWN_VALUE. ,TRUE
17,SPECIES_3,text,"matchList(layer, 1|UNKNOWN_VALUE);notNull(species_3);notEmpty(species_3);qc_prg4_lengthMatchList(species_3, {6}|NULL_VALUE)","lookupText(qc_prg4_species(species_3, 3), 'translation', 'species_code_mapping', 'qc_species_codes', 'casfri_species_codes')",Maps source value to SPECIES_3 using lookup table. Only runs if layer is 1. We don't have species info for layer 2 so return UNKNOWN_VALUE. ,TRUE
18,SPECIES_PER_3,integer,"matchList(layer, 1|-8886);notNull(species_per_3);notEmpty(species_per_3);qc_prg4_lengthMatchList(species_3, {6}|-8888)","qc_prg4_species_per_translation(species_per_3, 3)",Derives SPECIES_PER_3 from gr_ess. Custom function uses gr_ess to count number of species and assignes respective SPECIES_PER according to position.Only runs if layer is 1. We don't have species info for layer 2 so return UNKNOWN_VALUE. ,TRUE
19,SPECIES_4,text,false(),nothingText(),attribute does not occur,TRUE
20,SPECIES_PER_4,integer,false(),nothingInt(),attribute does not occur,TRUE
21,SPECIES_5,text,false(),nothingText(),attribute does not occur,TRUE
22,SPECIES_PER_5,integer,false(),nothingInt(),attribute does not occur,TRUE
23,SPECIES_6,text,false(),nothingText(),attribute does not occur,TRUE
24,SPECIES_PER_6,integer,false(),nothingInt(),attribute does not occur,TRUE
25,SPECIES_7,text,false(),nothingText(),attribute does not occur,TRUE
26,SPECIES_PER_7,integer,false(),nothingInt(),attribute does not occur,TRUE
27,SPECIES_8,text,false(),nothingText(),attribute does not occur,TRUE
28,SPECIES_PER_8,integer,false(),nothingInt(),attribute does not occur,TRUE
29,SPECIES_9,text,false(),nothingText(),attribute does not occur,TRUE
30,SPECIES_PER_9,integer,false(),nothingInt(),attribute does not occur,TRUE
31,SPECIES_10,text,false(),nothingText(),attribute does not occur,TRUE
32,SPECIES_PER_10,integer,false(),nothingInt(),attribute does not occur,TRUE
33,ORIGIN_UPPER,integer,"notNull(stand_photo_year);isInt(stand_photo_year);isBetween(stand_photo_year, 1900, 2020);notNull(cl_age);notEmpty(cl_age);matchTable(cl_age, 'translation', 'qc_standstructure_lookup', 'source_val',TRUE|-9999);isGreaterThan(lookupInt(cl_age, 'translation', 'qc_standstructure_lookup', 'source_val', 'num_of_layers', TRUE), layer|-9997)","XMinusYInt(stand_photo_year, lookupText(cl_age, 'translation', 'qc_standstructure_lookup', 'source_val', layer_origin, TRUE))","Check photo year is not null, is integer, and is between 1900 and 2020. Check age code is not null and is in table. Check the number of layers is equal to or greater than the layer being translated. Get age value for layer being processed using lookup table, then calculate origin as photo year minus age. No species, height or crown closure for layer 2, only origin is available.",TRUE
34,ORIGIN_LOWER,integer,"notNull(stand_photo_year);isInt(stand_photo_year);isBetween(stand_photo_year, 1900, 2020);notNull(cl_age);notEmpty(cl_age);matchTable(cl_age, 'translation', 'qc_standstructure_lookup', 'source_val',TRUE|-9999);isGreaterThan(lookupInt(cl_age, 'translation', 'qc_standstructure_lookup', 'source_val', 'num_of_layers', TRUE), layer|-9997)","XMinusYInt(stand_photo_year, lookupText(cl_age, 'translation', 'qc_standstructure_lookup', 'source_val', layer_origin, TRUE))","Check photo year is not null, is integer, and is between 1900 and 2020. Check age code is not null and is in table. Check the number of layers is equal to or greater than the layer being translated. Get age value for layer being processed using lookup table, then calculate origin as photo year minus age. No species, height or crown closure for layer 2, only origin is available.",TRUE
35,SITE_CLASS,text,false(),nothingText(),Attribute does not occur,TRUE
36,SITE_INDEX,double precision,false(),nothingDouble(),attribute does not occur,TRUE
