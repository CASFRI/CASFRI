rule_id,target_attribute,target_attribute_type,validation_rules,translation_rules,description,desc_uptodate_with_rules
0,ROW_TRANSLATION_RULE,NA,"notEmpty({species_1}, TRUE)",NA,"Translate only rows where sp1, sp2, sp3, sp4 or sp5 is not empty. Note that none of these rows include NFL info so each polygon is either LYR or NFL.", TRUE
1,CAS_ID,text,notEmpty(inventory_id);notNull(src_filename);notNull(ogc_fid),"padConcat({inventory_id, src_filename, src_filename, ogc_fid, ogc_fid}, {4,15,10,10,7}, {'x','x','x','0','0'}, '-', 'TRUE', 'TRUE')",Concatenates five attributes to create CAS_ID,TRUE
2,SOIL_MOIST_REG,text,"notNull(soil_moist_reg);matchList(soil_moist_reg,{'00','10','11','12','13','14','20','21','22','23','24','30','31','32','33','34','40','41','42','43','44','50','51','52','53','54','60','61','62','63','64','16'})
","mapText(soil_moist_reg, {'00','10','11','12','13','14','20','21','22','23','24','30','31','32','33','34','40','41','42','43','44','50','51','52','53','54','60','61','62','63','64','16'}, {'D','D','D','D','D','D','F','F','F','F','F','F','F','F','F','F','M','M','M','M','M','W','W','W','W','W','A','A','A','A','A','UNUSED_VALUE'})",Maps source codes to CASFRI codes,TRUE
3,STRUCTURE_PER,integer,true(),copyInt(100),No horizontal structure so structure_per should always be 100,TRUE
4,STRUCTURE_RANGE,double precision,false(),nothingDouble(),No complex stands identified,TRUE
5,LAYER,integer,true(),copyInt(layer),Copies 1 to LAYER,TRUE
6,LAYER_RANK,integer,true(),copyInt(layer),Copies 1 to LAYER_ID,TRUE
7,CROWN_CLOSURE_UPPER,integer,"lookupTextMatchList(cl_age, 'translation', 'qc_standstructure', 'num_of_layers', 1|-8886);notNull(cl_dens);notEmpty(cl_dens);notMatchList(cl_dens, {'H', 'I'} | -8887)","mapInt(cl_dens, {'A', 'B', 'C', 'D'}, {100, 79, 59, 39})","Validation rules: 1) check cl_age is not null, if it is polygon is NFL. 2) check cl_age code is in the lookup table. 3) check et_domi values is either null or in the expected list, null is allowed using the acceptNull parameter set to TRUE. 4) check when 2 layers are present and we can't get the layer 1 value using et_domi, that the 2 age codes from cl_age match the age codes in the sup and inf columns. 5) nothing to return when the etage table is empty and layer 2 is queried. In this case only one value is available to return. 6) nothing to return when etage table i empty and there are 2 layers. cl_dens only has one value for the entire polygon, it cannot be split by layer.       Translation rule: 1) If cl_age has a value and in_etage is 'O' and number of layers is 1, return sup_densitie. 2) If number of layers is two, first try and get the dominant layer from the et_domi column. If null or layers are EQUal, get dominant layer as the first layer code in cl_age. Compare this code to those in the sup and inf columns to see whether sup or inf is the dominant layer. Return the value from sup or inf depending on which is the dominant layer and whether layer 1 or 2 is being queried. If layer 1 is being queried, return the dominant layer value, otherwise return the other layers value. 3) If in_etage is 'N' and number of layers is 1 then we can return the single value present in the cl_dens attribute. cl_dens is a code representing intervals, return the upper value from the relavent interval. We can't return anything for layer 2, and we can't return anything if number of layer is 2 because cl_dens is a polygon level measure.",TRUE
8,CROWN_CLOSURE_LOWER,integer,"lookupTextMatchList(cl_age, 'translation', 'qc_standstructure', 'num_of_layers', 1|-8886);notNull(cl_dens);notEmpty(cl_dens);notMatchList(cl_dens, {'H', 'I'} | -8887)","mapInt(cl_dens, {'A', 'B', 'C', 'D'}, {80, 60, 40, 25})","Validation rules: 1) check cl_age is not null, if it is polygon is NFL. 2) check cl_age code is in the lookup table. 3) check et_domi values is either null or in the expected list, null is allowed using the acceptNull parameter set to TRUE. 4) check when 2 layers are present and we can't get the layer 1 value using et_domi, that the 2 age codes from cl_age match the age codes in the sup and inf columns. 5) nothing to return when the etage table is empty and layer 2 is queried. In this case only one value is available to return. 6) nothing to return when etage table i empty and there are 2 layers. cl_dens only has one value for the entire polygon, it cannot be split by layer.       Translation rule: 1) If cl_age has a value and in_etage is 'O' and number of layers is 1, return sup_densitie. 2) If number of layers is two, first try and get the dominant layer from the et_domi column. If null or layers are EQUal, get dominant layer as the first layer code in cl_age. Compare this code to those in the sup and inf columns to see whether sup or inf is the dominant layer. Return the value from sup or inf depending on which is the dominant layer and whether layer 1 or 2 is being queried. If layer 1 is being queried, return the dominant layer value, otherwise return the other layers value. 3) If in_etage is 'N' and number of layers is 1 then we can return the single value present in the cl_dens attribute. cl_dens is a code representing intervals, return the lower value from the relavent interval. We can't return anything for layer 2, and we can't return anything if number of layer is 2 because cl_dens is a polygon level measure.",TRUE
9,HEIGHT_UPPER,integer,"matchList(layer, 1|-8886);notNull(height_upper);notEmpty(height_upper);","mapInt(height_upper, {'1','2','3','4','5','6','7'}, {100, 21, 16, 11, 6, 3, 1})","Uses same logic as crown closure but returns height. The only difference is cl_haut represets the height of the top layer. So if in_etage is 'N', layer 1 height is always cl_haut, and layer 2 height is always unknown.",TRUE
10,HEIGHT_LOWER,integer,"matchList(layer, 1|-8886);notNull(height_lower);notEmpty(height_lower);","mapInt(height_lower, {'1','2','3','4','5','6','7'}, {22, 17, 12, 7, 4, 2, 0})","Uses same logic as crown closure but returns height. The only difference is cl_haut represets the height of the top layer. So if in_etage is 'N', layer 1 height is always cl_haut, and layer 2 height is always unknown.",TRUE
11,PRODUCTIVITY,text,false(|UNKNOWN_VALUE),nothingText(),No productivity info,TRUE
12,PRODUCTIVITY_TYPE,text,false(|UNKNOWN_VALUE),nothingText(),No productivity info,TRUE
13,SPECIES_1,text,"notNull(species_1);notEmpty(species_1);qc_prg4_lengthMatchList(species_1, {2, 4, 6}|NOT_APPLICABLE)","qc_prg4_species_translation(species_1, '1')",Maps source value to SPECIES_1 using lookup table,TRUE
14,SPECIES_PER_1,integer,"notNull(species_per_1);notEmpty(species_per_1);qc_prg4_lengthMatchList(species_1, {2, 4, 6}|-8887)","qc_prg4_species_per_translation(species_per_1, '1')",Copies source value to SPECIES_PER_1,TRUE
15,SPECIES_2,text,"notNull(species_2);notEmpty(species_2);qc_prg4_lengthMatchList(species_2, {4, 6}|NOT_APPLICABLE)","qc_prg4_species_translation(species_2, '2')",Maps source value to SPECIES_2 using lookup table,TRUE
16,SPECIES_PER_2,integer,"notNull(species_per_2);notEmpty(species_per_2);qc_prg4_lengthMatchList(species_2, {4, 6}|-8887)","qc_prg4_species_per_translation(species_per_2, '2')",Copies source value to SPECIES_PER_2,TRUE
17,SPECIES_3,text,"notNull(species_3);notEmpty(species_3);qc_prg4_lengthMatchList(species_3, {6}|NOT_APPLICABLE)","qc_prg4_species_translation(species_3, '3')",Maps source value to SPECIES_3 using lookup table,TRUE
18,SPECIES_PER_3,integer,"notNull(species_per_3);notEmpty(species_per_3);qc_prg4_lengthMatchList(species_3, {6}|-8887)","qc_prg4_species_per_translation(species_per_3, '3')",Copies source value to SPECIES_PER_3,TRUE
19,SPECIES_4,text,false(),nothingText(),attribute does not occur,TRUE
20,SPECIES_PER_4,integer,false(),nothingInt(),attribute does not occur,TRUE
21,SPECIES_5,text,false(),nothingText(),attribute does not occur,TRUE
22,SPECIES_PER_5,integer,false(),nothingInt(),attribute does not occur,TRUE
23,SPECIES_6,text,false(),nothingText(),attribute does not occur,TRUE
24,SPECIES_PER_6,integer,false(),nothingInt(),attribute does not occur,TRUE
25,SPECIES_7,text,false(),nothingText(),attribute does not occur,TRUE
26,SPECIES_PER_7,integer,false(),nothingInt(),attribute does not occur,TRUE
27,SPECIES_8,text,false(),nothingText(),attribute does not occur,TRUE
28,SPECIES_PER_8,integer,false(),nothingInt(),attribute does not occur,TRUE
29,SPECIES_9,text,false(),nothingText(),attribute does not occur,TRUE
30,SPECIES_PER_9,integer,false(),nothingInt(),attribute does not occur,TRUE
31,SPECIES_10,text,false(),nothingText(),attribute does not occur,TRUE
32,SPECIES_PER_10,integer,false(),nothingInt(),attribute does not occur,TRUE
33,ORIGIN_UPPER,integer,"isInt(stand_photo_year|-8886);notNull(cl_age);notEmpty(cl_age);matchTable(cl_age, 'translation', 'qc_standstructure', 'source_val','TRUE')","qc_origin_translation(cl_age, stand_photo_year)",Copies (l1estyr) to ORIGIN_UPPER,TRUE
34,ORIGIN_LOWER,integer,"isInt(stand_photo_year|-8886);notNull(cl_age);notEmpty(cl_age);matchTable(cl_age, 'translation', 'qc_standstructure', 'source_val','TRUE')","qc_origin_translation(cl_age, stand_photo_year)",Copies (l1estyr) to ORIGIN_LOWER,TRUE
35,SITE_CLASS,text,false(),nothingText(),Attribute does not occur,TRUE
36,SITE_INDEX,double precision,false(),nothingDouble(),attribute does not occur,TRUE
