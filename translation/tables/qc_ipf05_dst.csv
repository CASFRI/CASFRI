rule_id,target_attribute,target_attribute_type,validation_rules,translation_rules,description,desc_uptodate_with_rules
0,ROW_TRANSLATION_RULE,NA,"notEmpty({mod_1, mod_1_year, mod_2, mod_2_year}, TRUE)",NA,Translate rows that have type or year for at least one disturbance,TRUE
1,CAS_ID,text,notEmpty(inventory_id);notNull(src_filename);notNull(ogc_fid),"padConcat({inventory_id, src_filename, src_filename, ogc_fid, ogc_fid}, {4,15,10,10,7}, {'x','x','x','0','0'}, '-', 'TRUE', 'TRUE')",Concatenates five attributes to create CAS_ID,TRUE
2,DIST_TYPE_1,text,"notEmpty({mod_1, mod_1_year, mod_2, mod_2_year},TRUE);minIndexNotNull({mod_1_year, mod_2_year},{mod_1, mod_2}|UNKNOWN_VALUE);minIndexMatchTable({mod_1_year, mod_2_year},{mod_1,mod_2},'translation','qc_disturbance_lookup','dist_type')","minIndexLookupText({mod_1_year, mod_2_year},{mod_1,mod_2},'translation','qc_disturbance_lookup','dist_type')",Disturbances are found in 2 columns. If any of the 4 attributes have info then we know we have a dist_1. The DIST_TYPE_1 source value will be whichever disturbance has the smallest year value. Check the corresponding disturbance code is not null. If it is return UNKNOWN_VALUE. Get the disturbance value with the smallest year and run it through mapText.,TRUE
3,DIST_YEAR_1,integer,"notEmpty({mod_1, mod_1_year, mod_2, mod_2_year},TRUE);notEmpty({mod_1_year, mod_2_year},TRUE|-8886)","minint({mod_1_year, mod_2_year})","If any of the 4 attributes have a value, we know there is dist_1. If one year, it will always be assigned dist_1. If two years, smallest becomes dist_1. Catch the case where both years are null and return UNKNOWN_VALUE. Always take the smallest year for dist_1. Year can be null but in qc05 is never 0, so setNullTo and setZeroTo arguments are not required.",TRUE
4,DIST_EXT_UPPER_1,integer,false(),nothingInt(),Attribute does not occur,TRUE
5,DIST_EXT_LOWER_1,integer,false(),nothingInt(),Attribute does not occur,TRUE
6,DIST_TYPE_2,text,"hasCountOfNotNull({mod_1, mod_1_year}, {mod_2, mod_2_year}, 2, 'TRUE'|NOT_APPLICABLE);notEmpty({mod_1, mod_2},'FALSE'|UNKNOWN_VALUE);maxIndexMatchTable({mod_1_year, mod_2_year},{mod_1,mod_2},'translation','qc_disturbance_lookup','dist_type')","maxIndexLookupText({mod_1_year, mod_2_year},{mod_1, mod_2},'translation','qc_disturbance_lookup','dist_type', '9999', '9999')","Needs type or year from both slots to have a second disturbance. If we have second disturbance but the second type is null, return UNKNOWN_VALUE. This means we only have year for the second disturbance. Note that any=FALSE means it only passes if ALL values are notEmpty. Get the disturbance value with the highest year and run it through mapText. Use setNullTo of 9999 to make sure null years are counted as highest. If one of the years is null it will always for DIST_TYPE_2.",TRUE
7,DIST_YEAR_2,integer,"hasCountOfNotNull({mod_1, mod_1_year}, {mod_2, mod_2_year}, 2, 'TRUE'|-8887);notEmpty({mod_1_year, mod_2_year},'FALSE'|-8886)","maxint({mod_1_year, mod_2_year})","Needs type or year from both slots to have a second disturbance. If we have second disturbance but the second type is null, return UNKNOWN_VALUE. This means we only have year for the second disturbance. Always take the largest year for dist_1. This should only run in cases where there are values for both an_origine and an_perturb.",TRUE
8,DIST_EXT_UPPER_2,integer,false(),nothingInt(),Attribute does not occur,TRUE
9,DIST_EXT_LOWER_2,integer,false(),nothingInt(),Attribute does not occur,TRUE
10,DIST_TYPE_3,text,false(),nothingText(),Attribute does not occur,TRUE
11,DIST_YEAR_3,integer,false(),nothingInt(),Attribute does not occur,TRUE
12,DIST_EXT_UPPER_3,integer,false(),nothingInt(),Attribute does not occur,TRUE
13,DIST_EXT_LOWER_3,integer,false(),nothingInt(),Attribute does not occur,TRUE
14,LAYER,integer,false(|-8886),nothingInt(),Disturbance layer is unknown,TRUE
