rule_id,target_attribute,target_attribute_type,validation_rules,translation_rules,description,desc_uptodate_with_rules
0,ROW_TRANSLATION_RULE,NA,"matchList(typeclas,{'BE','BR','BU','CB','ES','LA','LL','LS','MO','MU','PO','RE','RI','RO','RS','RT','SW','AP','BP','EL','GP','TS','RD','SH','SU','PM','BL','BM','BY','HE','HF','HG','SL','ST'})",NA,Translate only rows where typeclas has precise values., TRUE
1,CAS_ID,text,notEmpty(inventory_id);notNull(src_filename);notNull(map_sheet_id);notNull(orig_stand_id);notNull(ogc_fid),"padConcat({inventory_id, src_filename, map_sheet_id, orig_stand_id, ogc_fid}, {4,15,10,10,7}, {'x','x','x','0','0'}, '-', 'TRUE', 'TRUE')",Concatenates five attributes to create CAS_ID.,TRUE
2,SOIL_MOIST_REG,text,"notNull(soil_moist_reg);notEmpty(soil_moist_reg);matchList(soil_moist_reg,{'vx','x','sx','sm','m','sg','hg','sd','hd'})","mapText(soil_moist_reg, {'vx','x','sx','sm','m','sg','hg','sd','hd'}, {'D','D','D','F','F','M','M','W','W'})",Maps source value to SOIL_MOIST_REG using lists of values.,TRUE
3,STRUCTURE_PER,integer,"matchList(stand_structure, {'H'}|-9997);notNull(structure_per);isInt(structure_per);isBetween(structure_per,1,9)","mapInt(structure_per, {1,2,3,4,5,6,7,8,9}, {10,20,30,40,50,60,70,80,90})",Only applies to horizontal stands. Copy source value to STRUCTURE_PER and multiply by 10. Source value 0 is translated to 100.,TRUE
4,LAYER,integer,true(),"fvi01_countOfNotNull({species_1_layer1, species_2_layer1, species_3_layer1, species_4_layer1}, {species_1_layer2, species_2_layer2, species_3_layer2, species_4_layer2}, {typeclas_layer1}, {typeclas_layer2}, layer, 'FALSE')","Count layers up to max_layer_number which is set by the createMappingsView() function in the workflow. Dummy variables are used here and in attribute_dependencies.csv to avoid two sets of values (sp1 and minsp1) being mapped to the same column (sp1). First set of dummy variables are overstory species 1 - 4, then understory species 1 - 4, then overstory nfl, then understory nfl. Custom helper function is a wrapper around countOfNotNull that first checks if the polygon-level type_class attributes have NFL values using matchList.",TRUE
5,LAYER_RANK,integer,false(),nothingInt(),No rank attribute.,TRUE
6,CROWN_CLOSURE_UPPER,integer,"notNull(crown_closure_upper);isInt(crown_closure_upper);isBetween(crown_closure_upper,0,100);matchList(typeclas, {'BL','BM','BY','HE','HF','HG','SL','ST'}|-8887)",copyInt(crown_closure_upper),"""The percentage of ground area covered by vertically projected crowns of the tree/ shrub / herb /bryoid layer within the polygon. Where vegetation is overlapping (such as a two-storey stand) only the visible portion of each layer is estimated."" Since polygon is either treed, shrub, herb or bryoid, crown closure is specific to whichever type is defined in the typeclas attribute. Only return crown closure here if row is nfl.",TRUE
7,CROWN_CLOSURE_LOWER,integer,"notNull(crown_closure_lower);isInt(crown_closure_lower);isBetween(crown_closure_lower,0,100);matchList(typeclas, {'BL','BM','BY','HE','HF','HG','SL','ST'}|-8887)",copyInt(crown_closure_lower),"""The percentage of ground area covered by vertically projected crowns of the tree/ shrub / herb /bryoid layer within the polygon. Where vegetation is overlapping (such as a two-storey stand) only the visible portion of each layer is estimated."" Since polygon is either treed, shrub, herb or bryoid, crown closure is specific to whichever type is defined in the typeclas attribute. Only return crown closure here if row is nfl.",TRUE
8,HEIGHT_UPPER,double precision,false(),nothingDouble(),Height only applies to dominant and co-dominant trees,TRUE
9,HEIGHT_LOWER,double precision,false(),nothingDouble(),Height only applies to dominant and co-dominant trees,TRUE
10,NAT_NON_VEG,text,"notNull(typeclas);notEmpty(typeclas);matchList(typeclas,{'BE','BR','BU','CB','ES','LA','LL','LS','MO','MU','PO','RE','RI','RO','RS','RT','SW'})","mapText(typeclas, {'BE','BR','BU','CB','ES','LA','LL','LS','MO','MU','PO','RE','RI','RO','RS','RT','SW'}, {'BE','RK','EX','EX','EX','LA','EX','WS','EX','EX','LA','LA','RI','RK','WS','RK','OC'})",Maps source value to NAT_NON_VEG using list of values,TRUE
11,NON_FOR_ANTH,text,"notNull(typeclas);notEmpty(typeclas);matchList(typeclas,{'AP','BP','EL','GP','TS','RD','SH','SU','PM'})","mapText(typeclas, {'AP','BP','EL','GP','TS','RD','SH','SU','PM'}, {'FA','SE','OT','IN','OT','FA','SE','SE','IN'})",Maps source value to NON_FOR_ANTH using list of values,TRUE
12,NON_FOR_VEG,text,"notNull(typeclas);notEmpty(typeclas);matchList(typeclas,{'BL','BM','BY','HE','HF','HG','SL','ST'})","mapText(typeclas, {'BL','BM','BY','HE','HF','HG','SL','ST'}, {'BR','BR','BR','HE','HF','HG','SL','ST'})",Maps source value to NON_FOR_VEG using list of values.,TRUE
