rule_id,target_attribute,target_attribute_type,validation_rules,translation_rules,description,desc_uptodate_with_rules
1,CAS_ID,text,notEmpty(inventory_id);notNull(src_filename);notNull(ogc_fid),"padConcat({inventory_id, src_filename, src_filename, ogc_fid, ogc_fid}, {4,15,10,10,7}, {'x','x','x','0','0'}, '-', 'TRUE', 'TRUE')",Concatenates five attributes to create CAS_ID,TRUE
2,SOIL_MOIST_REG,text,"notNull(cl_drai);matchList(cl_drai,{'00','10','11','12','13','14','20','21','22','23','24','30','31','32','33','34','40','41','42','43','44','50','51','52','53','54','60','61','62','63','64','16'})
","mapText(cl_drai, {'00','10','11','12','13','14','20','21','22','23','24','30','31','32','33','34','40','41','42','43','44','50','51','52','53','54','60','61','62','63','64','16'}, {'DRY','DRY','DRY','DRY','DRY','DRY','MESIC','MESIC','MESIC','MESIC','MESIC','MESIC','MESIC','MESIC','MESIC','MESIC','MOIST','MOIST','MOIST','MOIST','MOIST','WET','WET','WET','WET','WET','AQUATIC','AQUATIC','AQUATIC','AQUATIC','AQUATIC','UNUSED_VALUE'})",Maps source codes to CASFRI codes,TRUE4,LAYER,integer,true(),copyInt(layer),Copies 1 to LAYER,TRUE
5,LAYER_RANK,integer,true(),copyInt(layer),Copies 1 to LAYER_ID,TRUE
6,CROWN_CLOSURE_UPPER,integer,"notNull(cl_age);matchTable(cl_age, 'translation', 'qc_ipf05_standstructure');matchList(et_domi, {'EQU', 'SUP', 'INF'}, 'FALSE', 'TRUE');tie01_2layer_age_codes_validation(cl_age, 'translation', 'qc_ipf05_standstructure', in_etage, et_domi, sup_cl_age_et, inf_cl_age_et);tie01_not_etage_notnull_validation(in_etage, cl_dens);tie01_not_etage_layer1_validation(in_etage, layer);tie01_not_etage_dens_layers_validation(in_etage, cl_age, 'translation', 'qc_ipf05_standstructure')","tie01_crownclosure_translation(cl_age, 'translation', 'qc_ipf05_standstructure', dummy_lookupcol, in_etage, et_domi, sup_cl_age_et, inf_cl_age_et, sup_densite, inf_densite, cl_dens, layer, 'upper')","Validation rules: 1) check cl_age is not null, if it is polygon is NFL. 2) check cl_age code is in the lookup table. 3) check et_domi values is either null or in the expected list, null is allowed using the acceptNull parameter set to TRUE. 4) check when 2 layers are present and we can't get the layer 1 value using et_domi, that the 2 age codes from cl_age match the age codes in the sup and inf columns. 5) nothing to return when the etage table is empty and layer 2 is queried. In this case only one value is available to return. 6) nothing to return when etage table i empty and there are 2 layers. cl_dens only has one value for the entire polygon, it cannot be split by layer.       Translation rule: 1) If cl_age has a value and in_etage is 'O' and number of layers is 1, return sup_densitie. 2) If number of layers is two, first try and get the dominant layer from the et_domi column. If null or layers are EQUal, get dominant layer as the first layer code in cl_age. Compare this code to those in the sup and inf columns to see whether sup or inf is the dominant layer. Return the value from sup or inf depending on which is the dominant layer and whether layer 1 or 2 is being queried. If layer 1 is being queried, return the dominant layer value, otherwise return the other layers value. 3) If in_etage is 'N' and number of layers is 1 then we can return the single value present in the cl_dens attribute. cl_dens is a code representing intervals, return the upper value from the relavent interval. We can't return anything for layer 2, and we can't return anything if number of layer is 2 because cl_dens is a polygon level measure.",TRUE
7,CROWN_CLOSURE_LOWER,integer,"notNull(cl_age);matchTable(cl_age, 'translation', 'qc_ipf05_standstructure');matchList(et_domi, {'EQU', 'SUP', 'INF'}, 'FALSE', 'TRUE');tie01_2layer_age_codes_validation(cl_age, 'translation', 'qc_ipf05_standstructure', in_etage, et_domi, sup_cl_age_et, inf_cl_age_et);tie01_not_etage_notnull_validation(in_etage, cl_dens);tie01_not_etage_layer1_validation(in_etage, layer);tie01_not_etage_dens_layers_validation(in_etage, cl_age, 'translation', 'qc_ipf05_standstructure')","tie01_crownclosure_translation(cl_age, 'translation', 'qc_ipf05_standstructure', dummy_lookupcol, in_etage, et_domi, sup_cl_age_et, inf_cl_age_et, sup_densite, inf_densite, cl_dens, layer, 'lower')","Validation rules: 1) check cl_age is not null, if it is polygon is NFL. 2) check cl_age code is in the lookup table. 3) check et_domi values is either null or in the expected list, null is allowed using the acceptNull parameter set to TRUE. 4) check when 2 layers are present and we can't get the layer 1 value using et_domi, that the 2 age codes from cl_age match the age codes in the sup and inf columns. 5) nothing to return when the etage table is empty and layer 2 is queried. In this case only one value is available to return. 6) nothing to return when etage table i empty and there are 2 layers. cl_dens only has one value for the entire polygon, it cannot be split by layer.       Translation rule: 1) If cl_age has a value and in_etage is 'O' and number of layers is 1, return sup_densitie. 2) If number of layers is two, first try and get the dominant layer from the et_domi column. If null or layers are EQUal, get dominant layer as the first layer code in cl_age. Compare this code to those in the sup and inf columns to see whether sup or inf is the dominant layer. Return the value from sup or inf depending on which is the dominant layer and whether layer 1 or 2 is being queried. If layer 1 is being queried, return the dominant layer value, otherwise return the other layers value. 3) If in_etage is 'N' and number of layers is 1 then we can return the single value present in the cl_dens attribute. cl_dens is a code representing intervals, return the lower value from the relavent interval. We can't return anything for layer 2, and we can't return anything if number of layer is 2 because cl_dens is a polygon level measure.",TRUE
8,HEIGHT_UPPER,integer,"notNull(cl_age);matchTable(cl_age, 'translation', 'qc_ipf05_standstructure');matchList(et_domi, {'EQU', 'SUP', 'INF'}, 'FALSE', 'TRUE');tie01_2layer_age_codes_validation(cl_age, 'translation', 'qc_ipf05_standstructure', in_etage, et_domi, sup_cl_age_et, inf_cl_age_et);tie01_not_etage_notnull_validation(in_etage, cl_dens);tie01_not_etage_layer1_validation(in_etage, layer)","tie01_height_translation(cl_age, 'translation', 'qc_ipf05_standstructure', dummy_lookupcol, in_etage, et_domi, sup_cl_age_et, inf_cl_age_et, sup_hauteur, inf_hauteur, cl_haut, layer, 'upper')","Uses same logic as crown closure but returns height. The only difference is cl_haut represets the height of the top layer. So if in_etage is 'N', layer 1 height is always cl_haut, and layer 2 height is always unknown.",TRUE
9,HEIGHT_LOWER,integer,"notNull(cl_age);matchTable(cl_age, 'translation', 'qc_ipf05_standstructure');matchList(et_domi, {'EQU', 'SUP', 'INF'}, 'FALSE', 'TRUE');tie01_2layer_age_codes_validation(cl_age, 'translation', 'qc_ipf05_standstructure', in_etage, et_domi, sup_cl_age_et, inf_cl_age_et);tie01_not_etage_notnull_validation(in_etage, cl_dens);tie01_not_etage_layer1_validation(in_etage, layer)","tie01_height_translation(cl_age, 'translation', 'qc_ipf05_standstructure', dummy_lookupcol, in_etage, et_domi, sup_cl_age_et, inf_cl_age_et, sup_hauteur, inf_hauteur, cl_haut, layer, 'lower')","Uses same logic as crown closure but returns height. The only difference is cl_haut represets the height of the top layer. So if in_etage is 'N', layer 1 height is always cl_haut, and layer 2 height is always unknown.",TRUE
10,PRODUCTIVE_FOR,text,false(),nothingText(),Correct translation has not been determined.,FALSE
11,SPECIES_1,text,,,Maps source value to SPECIES_1 using lookup table,FALSE
12,SPECIES_PER_1,integer,,,Copies source value to SPECIES_PER_1,FALSE
13,SPECIES_2,text,,,Maps source value to SPECIES_2 using lookup table,FALSE
14,SPECIES_PER_2,integer,,,Copies source value to SPECIES_PER_2,FALSE
15,SPECIES_3,text,,,Maps source value to SPECIES_3 using lookup table,FALSE
16,SPECIES_PER_3,integer,,,Copies source value to SPECIES_PER_3,FALSE
17,SPECIES_4,text,false(),nothingText(),attribute does not occur,FALSE
18,SPECIES_PER_4,integer,false(),nothingInt(),attribute does not occur,FALSE
19,SPECIES_5,text,false(),nothingText(),attribute does not occur,FALSE
20,SPECIES_PER_5,integer,false(),nothingInt(),attribute does not occur,FALSE
21,SPECIES_6,text,false(),nothingText(),attribute does not occur,FALSE
22,SPECIES_PER_6,integer,false(),nothingInt(),attribute does not occur,FALSE
23,SPECIES_7,text,false(),nothingText(),attribute does not occur,FALSE
24,SPECIES_PER_7,integer,false(),nothingInt(),attribute does not occur,FALSE
25,SPECIES_8,text,false(),nothingText(),attribute does not occur,FALSE
26,SPECIES_PER_8,integer,false(),nothingInt(),attribute does not occur,FALSE
27,SPECIES_9,text,false(),nothingText(),attribute does not occur,FALSE
28,SPECIES_PER_9,integer,false(),nothingInt(),attribute does not occur,FALSE
29,SPECIES_10,text,false(),nothingText(),attribute does not occur,FALSE
30,SPECIES_PER_10,integer,false(),nothingInt(),attribute does not occur,FALSE
31,ORIGIN_UPPER,integer,,,Copies (l1estyr) to ORIGIN_UPPER,FALSE
32,ORIGIN_LOWER,integer,,,Copies (l1estyr) to ORIGIN_LOWER,FALSE
33,SITE_CLASS,text,false(),nothingText(),Attribute does not occur,FALSE
34,SITE_INDEX,double precision,false(),nothingDouble(),attribute does not occur,FALSE
