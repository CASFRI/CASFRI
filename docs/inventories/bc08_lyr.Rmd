---  
title: "LYR Attributes"
output:  
  html_document:  
    code_folding: hide
    toc: true
    toc_float:
      collapsed: false
    css: styles.css
---  

<br>

# What's new

  * Revised some of the code and added comments (2019-05-20)
  * Revised productive_for (2019-05-15)
  * LYR attributes are ready to reviewed (2019-05-14)

<br>

# Overview

  * See comments under individual attribute heading

<br>

# Attributes

## soil_moist_reg {.tabset}

  * The attribute soil_moist_reg is translated from the BC attribute soil_moisture_regime_1 (see code below for rules)

```{r echo=TRUE, message=FALSE, warning=FALSE}  
x = mutate(x, soil_moist_reg = case_when(
    is.na(soil_moisture_regime_1) ~ "NULL_VALUE",
    str_trim(soil_moisture_regime_1)=="" ~ "EMPTY_STRING",
    soil_moisture_regime_1 %in% c(0,1,2) ~ "D",
    soil_moisture_regime_1 %in% c(3,4) ~ "F",
    soil_moisture_regime_1 %in% c(5,6) ~ "M",
    soil_moisture_regime_1 %in% c(7,8) ~ "W",
    TRUE ~ "NOT_IN_SET"))
```

### RAWFRI

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["soil_moisture_regime_1"], graph.col=FALSE, max.distinct.values=99)
```
### CASFRI

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["soil_moist_reg"], graph.col=FALSE, max.distinct.values=99)
```

## structure_per {.tabset}

The attribute structure_per is not created from an FRI attribute:

  * assigned a value of UNDEF in cas04?

```{r echo=TRUE, message=FALSE, warning=FALSE}  
x = mutate(x, structure_per=0)
```

### RAWFRI

### CASFRI

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["structure_per"], graph.col=FALSE, max.distinct.values=99)
```

## layer {.tabset}

The attribute layer is not created from an FRI attribute:

  * assigned a value of 1

```{r echo=TRUE, message=FALSE, warning=FALSE}  
x = mutate(x, layer=1)
```

### RAWFRI

### CASFRI

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["layer"], graph.col=FALSE, max.distinct.values=99)
```

## layer_rank {.tabset}

The attribute layer_rank is not created from an FRI attribute:

  * assigned a value of 1

```{r echo=TRUE, message=FALSE, warning=FALSE}  
x = mutate(x, layer_rank=1)
```

### RAWFRI

### CASFRI

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["layer_rank"], graph.col=FALSE, max.distinct.values=99)
```

## crown_closure {.tabset}

  * crown_closure can be copied directly; it is an integer ranging from 0-100
  * Null values should be assigned error code -8888

```{r echo=TRUE, message=FALSE, warning=FALSE}  
x = mutate(x, crown_closure_lower=case_when(
    is.na(crown_closure) ~ as.integer(-8888),
    crown_closure < 0 | crown_closure > 100 ~ as.integer(-9999),
    TRUE ~ crown_closure),
    crown_closure_upper=crown_closure_lower)
```

### RAWFRI

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["crown_closure"], graph.col=FALSE, max.distinct.values=101)
```

### CASFRI (lower)

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["crown_closure_lower"], graph.col=FALSE, max.distinct.values=101)
```

### CASFRI (upper)

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["crown_closure_upper"], graph.col=FALSE, max.distinct.values=101)
```

## height {.tabset}

  * proj_height_1 can be copied directly; it is a numeric attribute ranging from 0.0-93.5
  * CASFRI specifies that values can range from 0-100, implying that if there if height>100 then it should be assigned 100 (check on this?)
  * Null values should be assigned error code -8888

```{r echo=TRUE, message=FALSE, warning=FALSE}  
x = mutate(x, height_upper=case_when(
    is.na(proj_height_1) ~ -8888,
    proj_height_1 < 0.1 | proj_height_1 > 100 ~ -9999,
    TRUE ~ proj_height_1),
    height_lower=height_upper)
```

### RAWFRI

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["proj_height_1"], graph.col=FALSE, max.distinct.values=99)
```

### CASFRI (lower)

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["height_lower"], graph.col=FALSE, max.distinct.values=99)
```

### CASFRI (upper)

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["height_upper"], graph.col=FALSE, max.distinct.values=99)
```

## species_1-10 {.tabset}

  * The attributes species_1 - species_6 use a lookup table to translate species codes to the CASFRI standard. Here, we demonstrate the code for species_1 only since the same procedure is used for the other species.

```{r echo=TRUE, message=FALSE, warning=FALSE}  
sppList = read_csv("../../translation/tables/lookup/bc_vri01_species.csv")
x = mutate(x, species_1=case_when(
    is.na(species_cd_1) ~ "NULL_VALUE",
    str_trim(species_cd_1)=="" ~ "EMPTY_STRING",
    !species_cd_1 %in% sppList$SOURCE_VAL ~ "NOT_IN_SET",
    TRUE ~ mapvalues(species_cd_1, sppList$SOURCE_VAL, sppList$SPEC1)))
```

### RAWFRI

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["species_cd_1"], graph.col=FALSE, max.distinct.values=99)
```
### CASFRI

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["species_1"], graph.col=FALSE, max.distinct.values=99)
```

## species_per_1-10 {.tabset}

  * The attributes species_per_1 - species_per_6 are simply copied from the attributes species_pct_1 - species_pct_6

```{r echo=TRUE, message=FALSE, warning=FALSE}  
x = mutate(x, species_per_1=case_when(
    is.na(species_pct_1) ~ -8888,
    species_pct_1 < 0 | species_pct_1 > 100 ~ -9999,
    TRUE ~ species_pct_1))
```

### RAWFRI

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["species_pct_1"], graph.col=FALSE, max.distinct.values=99)
```

### CASFRI

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["species_per_1"], graph.col=FALSE, max.distinct.values=99)
```

## productive_for {.tabset}

  * There is some confusion here. The CASFRI specs describe an attribute named UNPRODUCTIVE_FOREST with possible values including TM, OM, AL, SD, SC, NP, P. However, this attribue is not in the actual CAS_04 implementation. Instead there is a PRODUCTIVE_FOR attribute which takes values PF or PP. This latter attribute was created from multiple attributes (see CAS_04 Perl code).
  * Here we use the new and simpler FOR_MGMT_LAND_BASE_IND (Y or N; see docs/forest_management_land_base_definition.pdf) attribute to identify PRODUCTIVE_FOR.

```{r echo=TRUE, message=FALSE, warning=FALSE}  
x = mutate(x, productive_for = if_else(
    for_mgmt_land_base_ind=="Y", "PF", "PP"))
```

### RAWFRI

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["for_mgmt_land_base_ind"], graph.col=FALSE, max.distinct.values=99)
```

### CASFRI

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["productive_for"], graph.col=FALSE, max.distinct.values=99)
```

## origin {.tabset}

  * The attribute origin is a simple calculation that substractc reference_year from proj_age_1
  * Do we need a new helper function?

```{r echo=TRUE, message=FALSE, warning=FALSE}
x = mutate(x, projected_year=as.double(substr(projected_date, 1, 4)),
              origin_upper=if_else(proj_age_1==0, -9999, (projected_year - proj_age_1)),
              origin_lower=if_else(proj_age_1==0, -9999, (projected_year - proj_age_1)))
```

### RAWFRI

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["proj_age_1"], graph.col=FALSE, max.distinct.values=99)
```

### CASFRI (lower)

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["origin_lower"], graph.col=FALSE, max.distinct.values=99)
```

### CASFRI (upper)

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["origin_upper"], graph.col=FALSE, max.distinct.values=99)
```

## site_class {.tabset}

  * Is site_class used in the BC inventory? Check Perl code.

```{r echo=TRUE, message=FALSE, warning=FALSE}  
friList = c('U','F','M','G')
casList = c('U','P','M','G')
x = mutate(x, site_class=0)
```

### RAWFRI

```{r echo=FALSE, message=FALSE, warning=FALSE}  
#dfSummary(x[""], graph.col=FALSE, max.distinct.values=99)
```

### CASFRI

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["site_class"], graph.col=FALSE, max.distinct.values=99)
```

## site_index {.tabset}

 * In BC site_index uses site_index if available or est_site_index otherwise.
 * Note that, in this code segment, we name the variable lyr_site_index since site_index already exists in the BC inventory

```{r echo=TRUE, message=FALSE, warning=FALSE}
x = mutate(x, lyr_site_index=case_when(
    is.na(site_index) & is.na(est_site_index) ~ -8888,
    is.na(site_index) & !is.na(est_site_index) ~ est_site_index,
    TRUE ~ site_index))
```

### RAWFRI

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["site_index"], graph.col=FALSE, max.distinct.values=99)
```

### CASFRI

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["lyr_site_index"], graph.col=FALSE, max.distinct.values=99)
```
